================================================================================
iAHRS Driver C++ vs Python 성능 테스트 시나리오
================================================================================

[테스트 환경 요구사항]
- 하드웨어: 동일한 시스템 (CPU, RAM, 시리얼 포트)
- OS: Ubuntu 22.04 (ROS2 Humble)
- 센서: iAHRS IMU 센서 연결 필수
- 측정 도구: top, valgrind, ros2 topic, time

================================================================================
테스트 1: 시작 시간 측정
================================================================================

목표: 노드 초기화부터 첫 데이터 발행까지 시간 측정

[C++ 실행]
$ time ros2 run iahrs_ros2 iahrs_driver

[Python 실행]
$ time python3 src/iahrs_driver.py

[측정 항목]
- 노드 초기화 시간
- 시리얼 포트 연결 시간
- 첫 IMU 데이터 발행까지 소요 시간
- 총 실행 시간 (real, user, sys)

[예상 결과]
C++: 초기화 시간 더 빠름 (컴파일된 바이너리)
Python: 인터프리터 로딩 오버헤드로 느림


================================================================================
테스트 2: CPU 사용률 측정
================================================================================

목표: 100Hz 루프 동작 중 CPU 사용률 비교

[C++ 실행 및 측정]
$ ros2 run iahrs_ros2 iahrs_driver &
$ PID=$(pgrep iahrs_driver)
$ top -p $PID -d 1 -n 60 > cpp_cpu.log

[Python 실행 및 측정]
$ python3 src/iahrs_driver.py &
$ PID=$(pgrep -f "python3.*iahrs_driver")
$ top -p $PID -d 1 -n 60 > python_cpu.log

[측정 항목]
- 평균 CPU 사용률 (%)
- 피크 CPU 사용률 (%)
- CPU 사용 안정성 (표준편차)
- 멀티코어 활용도

[예상 결과]
C++: 낮고 안정적인 CPU 사용률
Python: C++보다 2-5배 높은 CPU 사용률, GC로 인한 스파이크


================================================================================
테스트 3: 메모리 사용량 측정
================================================================================

목표: 런타임 메모리 사용량 및 메모리 누수 확인

[C++ 메모리 분석]
$ valgrind --leak-check=full --show-leak-kinds=all \
  --log-file=cpp_valgrind.log \
  ros2 run iahrs_ros2 iahrs_driver

# 실행 중 메모리 사용량
$ pmap $(pgrep iahrs_driver) | tail -1

[Python 메모리 분석]
$ /usr/bin/time -v python3 src/iahrs_driver.py 2> python_mem.log

# 실행 중 메모리 사용량
$ ps aux | grep "python3.*iahrs_driver"

[측정 항목]
- RSS (Resident Set Size)
- VSZ (Virtual Memory Size)
- 메모리 누수 여부
- 초기 메모리 vs 10분 후 메모리

[예상 결과]
C++: 5-10MB, 메모리 누수 없음
Python: 30-50MB, GC로 인한 메모리 변동


================================================================================
테스트 4: 주기 정확도 측정 (100Hz 목표)
================================================================================

목표: 100Hz 루프의 실제 주기 및 jitter 측정

[실행]
$ ros2 run iahrs_ros2 iahrs_driver  # C++ 버전
$ ros2 topic hz /iahrs_imu/data --window 1000

$ python3 src/iahrs_driver.py  # Python 버전
$ ros2 topic hz /iahrs_imu/data --window 1000

[측정 항목]
- 평균 주파수 (Hz)
- 최소/최대 주기
- 주기 표준편차 (jitter)
- 목표 100Hz 달성 여부

[예상 결과]
C++: 99.9-100.1Hz, 낮은 jitter (< 0.5ms)
Python: 95-100Hz, 높은 jitter (> 2ms), GC pause 발생


================================================================================
테스트 5: 처리량 (Throughput) 측정
================================================================================

목표: 1분간 발행된 메시지 수 및 데이터 손실률 확인

[실행]
# 메시지 카운트
$ timeout 60 ros2 topic echo /iahrs_imu/data --no-arr | grep "header:" | wc -l

# 예상 메시지 수: 60초 * 100Hz = 6000개

[측정 항목]
- 총 메시지 수
- 데이터 손실률 = (6000 - 실제 메시지 수) / 6000 * 100
- 연속 메시지 손실 발생 여부

[예상 결과]
C++: 6000개 (손실률 0%)
Python: 5500-5900개 (손실률 2-8%)


================================================================================
테스트 6: 시리얼 통신 레이턴시
================================================================================

목표: 센서 쿼리부터 응답까지 시간 측정

[코드 수정 필요]
C++ (iahrs_driver.cpp:159-224):
  send_and_receive 함수 시작/종료 시점에 타이머 추가

Python (iahrs_driver.py:106-159):
  send_and_receive 함수 시작/종료 시점에 타이머 추가

측정 코드 예시:
  auto start = std::chrono::high_resolution_clock::now();
  // ... send_and_receive 로직 ...
  auto end = std::chrono::high_resolution_clock::now();
  duration = end - start;

[측정 항목]
- 평균 레이턴시 (ms)
- P50, P95, P99 레이턴시
- 최대 레이턴시

[예상 결과]
C++: 평균 1-2ms, P99 < 5ms
Python: 평균 3-5ms, P99 > 10ms (pyserial 오버헤드)


================================================================================
테스트 7: 장시간 안정성 테스트
================================================================================

목표: 24시간 연속 실행 후 안정성 및 메모리 누수 확인

[실행]
$ ros2 run iahrs_ros2 iahrs_driver > cpp_24h.log 2>&1 &
$ PID_CPP=$!

$ python3 src/iahrs_driver.py > python_24h.log 2>&1 &
$ PID_PYTHON=$!

# 1시간마다 메모리 기록
$ while true; do
    echo "$(date): $(ps -p $PID_CPP -o rss=)" >> cpp_mem_tracking.log
    echo "$(date): $(ps -p $PID_PYTHON -o rss=)" >> python_mem_tracking.log
    sleep 3600
  done

[측정 항목]
- 크래시/에러 발생 여부
- 메모리 증가량 (0시간 vs 24시간)
- 성능 저하 여부 (초기 vs 24시간 후 Hz)
- 로그에 기록된 에러/경고 수

[예상 결과]
C++: 안정적, 메모리 증가 없음
Python: GC로 인한 주기적 메모리 변동, 가능한 메모리 누수


================================================================================
테스트 8: 컴파일/실행 파일 크기 비교
================================================================================

[C++ 바이너리 크기]
$ ls -lh install/iahrs_ros2/lib/iahrs_ros2/iahrs_driver

[Python 스크립트 크기]
$ ls -lh src/iahrs_driver.py

[의존성 크기]
$ du -sh /opt/ros/humble  # ROS2 공통
$ du -sh ~/.local/lib/python3.10/site-packages/serial  # pyserial

[측정 항목]
- 실행 파일 크기
- 전체 의존성 크기
- 배포 패키지 크기

[예상 결과]
C++: 실행 파일 수백 KB, 의존성 작음
Python: 스크립트 11KB, 하지만 Python 런타임 + 라이브러리 필요


================================================================================
테스트 9: 멀티 인스턴스 동시 실행
================================================================================

목표: 동일 시스템에서 여러 노드 동시 실행 시 성능 저하 측정

[실행]
# 가상 시리얼 포트 생성 (센서 없이 테스트 가능)
$ socat -d -d pty,raw,echo=0 pty,raw,echo=0

# 3개 노드 동시 실행
$ ros2 run iahrs_ros2 iahrs_driver &
$ ros2 run iahrs_ros2 iahrs_driver &
$ ros2 run iahrs_ros2 iahrs_driver &

[측정 항목]
- 총 CPU 사용률
- 총 메모리 사용량
- 각 노드의 Hz 유지 여부
- 컨텍스트 스위칭 오버헤드

[예상 결과]
C++: 선형적 리소스 증가, 모든 노드 100Hz 유지
Python: GIL로 인한 병목, Hz 저하


================================================================================
테스트 요약 및 체크리스트
================================================================================

[ ] 테스트 1: 시작 시간 (C++ vs Python)
[ ] 테스트 2: CPU 사용률 (1분간 측정)
[ ] 테스트 3: 메모리 사용량 (valgrind + time)
[ ] 테스트 4: 주기 정확도 (ros2 topic hz)
[ ] 테스트 5: 처리량 (메시지 손실률)
[ ] 테스트 6: 시리얼 레이턴시 (코드 수정 필요)
[ ] 테스트 7: 24시간 안정성 (장기 테스트)
[ ] 테스트 8: 파일 크기 비교
[ ] 테스트 9: 멀티 인스턴스 실행

[결과 정리 형식]
각 테스트 결과를 표로 정리:

| 테스트 항목          | C++      | Python   | 비율 (C++/Py) |
|---------------------|----------|----------|---------------|
| 시작 시간           |          |          |               |
| 평균 CPU (%)        |          |          |               |
| 메모리 RSS (MB)     |          |          |               |
| 평균 주파수 (Hz)    |          |          |               |
| 처리량 (msg/min)    |          |          |               |
| 레이턴시 P99 (ms)   |          |          |               |
| 24h 메모리 증가     |          |          |               |
| 바이너리 크기       |          |          |               |
